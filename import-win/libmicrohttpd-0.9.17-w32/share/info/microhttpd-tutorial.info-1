This is microhttpd-tutorial.info, produced by makeinfo version 4.3 from
microhttpd-tutorial.texi.

INFO-DIR-SECTION GNU Libraries
START-INFO-DIR-ENTRY
* libmicrohttpdtutorial: (microhttpd).  A tutorial for GNU libmicrohttpd.
END-INFO-DIR-ENTRY

This tutorial documents GNU libmicrohttpd version 0.9.16, last updated
2 Nov 2011.

   Copyright (c)  2008  Sebastian Gerhardt.

   Copyright (c)  2010, 2011  Christian Grothoff.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".
   

File: microhttpd-tutorial.info,  Node: Top,  Next: Introduction,  Up: (dir)

Top
***

* Menu:

* Introduction::
* Hello browser example::
* Exploring requests::
* Response headers::
* Supporting basic authentication::
* Processing POST data::
* Improved processing of POST data::
* Session management::
* Adding a layer of security::
* Bibliography::
* License text::
* Example programs::


File: microhttpd-tutorial.info,  Node: Introduction,  Next: Hello browser example,  Prev: Top,  Up: Top

Introduction
************

   This tutorial is for developers who want to learn how they can add
HTTP serving capabilities to their applications with the _GNU
libmicrohttpd_ library, abbreviated _MHD_.  The reader will learn how to
implement basic HTTP functions from simple executable sample programs
that implement various features.

   The text is supposed to be a supplement to the API reference manual
of _GNU libmicrohttpd_ and for that reason does not explain many of the
parameters.  Therefore, the reader should always consult the manual to
find the exact meaning of the functions used in the tutorial.
Furthermore, the reader is encouraged to study the relevant _RFCs_,
which document the HTTP standard.

   _GNU libmicrohttpd_ is assumed to be already installed.  This
tutorial is written for version 0.9.16.  At the time being, this
tutorial has only been tested on _GNU/Linux_ machines even though
efforts were made not to rely on anything that would prevent the
samples from being built on similar systems.

History
=======

   This tutorial was originally written by Sebastian Gerhardt for MHD
0.4.0.  It was slighly polished and updated to MHD 0.9.0 by Christian
Grothoff.


File: microhttpd-tutorial.info,  Node: Hello browser example,  Next: Exploring requests,  Prev: Introduction,  Up: Top

Hello browser example
*********************

   The most basic task for a HTTP server is to deliver a static text
message to any client connecting to it.  Given that this is also easy
to implement, it is an excellent problem to start with.

   For now, the particular URI the client asks for shall have no effect
on the message that will be returned. In addition, the server shall end
the connection after the message has been sent so that the client will
know there is nothing more to expect.

   The C program `hellobrowser.c', which is to be found in the examples
section, does just that.  If you are very eager, you can compile and
start it right away but it is advisable to type the lines in by
yourself as they will be discussed and explained in detail.

   After the necessary includes and the definition of the port which
our server should listen on

#include <sys/types.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <microhttpd.h>

#define PORT 8888

the desired behaviour of our server when HTTP request arrive has to be
implemented. We already have agreed that it should not care about the
particular details of the request, such as who is requesting what. The
server will respond merely with the same small HTML page to every
request.

   The function we are going to write now will be called by _GNU
libmicrohttpd_ every time an appropriate request comes in. While the
name of this callback function is arbitrary, its parameter list has to
follow a certain layout. So please, ignore the lot of parameters for
now, they will be explained at the point they are needed. We have to
use only one of them, `struct MHD_Connection *connection', for the
minimalistic functionality we want to archive at the moment.

   This parameter is set by the _libmicrohttpd_ daemon and holds the
necessary information to relate the call with a certain connection.
Keep in mind that a server might have to satisfy hundreds of concurrent
connections and we have to make sure that the correct data is sent to
the destined client. Therefore, this variable is a means to refer to a
particular connection if we ask the daemon to sent the reply.

   Talking about the reply, it is defined as a string right after the
function header

int answer_to_connection (void *cls, struct MHD_Connection *connection, 
                          const char *url, 
                          const char *method, const char *version, 
                          const char *upload_data, 
                          size_t *upload_data_size, void **con_cls)
{
  const char *page  = "<html><body>Hello, browser!</body></html>";

HTTP is a rather strict protocol and the client would certainly
consider it "inappropriate" if we just sent the answer string "as is".
Instead, it has to be wrapped with additional information stored in
so-called headers and footers.  Most of the work in this area is done
by the library for us--we just have to ask. Our reply string packed in
the necessary layers will be called a "response".  To obtain such a
response we hand our data (the reply-string) and its size over to the
`MHD_create_response_from_buffer' function. The last two parameters
basically tell _MHD_ that we do not want it to dispose the message data
for us when it has been sent and there also needs no internal copy to
be done because the _constant_ string won't change anyway.


  struct MHD_Response *response;
  int ret;

  response = MHD_create_response_from_buffer (strlen (page),
                                            (void*) page, MHD_RESPMEM_PERSISTENT);

Now that the the response has been laced up, it is ready for delivery
and can be queued for sending.  This is done by passing it to another
_GNU libmicrohttpd_ function. As all our work was done in the scope of
one function, the recipient is without doubt the one associated with the
local variable `connection' and consequently this variable is given to
the queue function.  Every HTTP response is accompanied by a status
code, here "OK", so that the client knows this response is the intended
result of his request and not due to some error or malfunction.

   Finally, the packet is destroyed and the return value from the queue
returned, already being set at this point to either MHD_YES or MHD_NO
in case of success or failure.


  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);
  MHD_destroy_response (response);

  return ret;
}

With the primary task of our server implemented, we can start the
actual server daemon which will listen on `PORT' for connections. This
is done in the main function.

int main ()
{
  struct MHD_Daemon *daemon;

  daemon = MHD_start_daemon (MHD_USE_SELECT_INTERNALLY, PORT, NULL, NULL, 
                             &answer_to_connection, NULL, MHD_OPTION_END);
  if (NULL == daemon) return 1;

The first parameter is one of three possible modes of operation. Here
we want the daemon to run in a separate thread and to manage all
incoming connections in the same thread. This means that while
producing the response for one connection, the other connections will
be put on hold. In this example, where the reply is already known and
therefore the request is served quickly, this poses no problem.

   We will allow all clients to connect regardless of their name or
location, therefore we do not check them on connection and set the
forth and fifth parameter to NULL.

   Parameter six is the address of the function we want to be called
whenever a new connection has been established. Our
`answer_to_connection' knows best what the client wants and needs no
additional information (which could be passed via the next parameter)
so the next parameter is NULL. Likewise, we do not need to pass extra
options to the daemon so we just write the MHD_OPTION_END as the last
parameter.

   As the server daemon runs in the background in its own thread, the
execution flow in our main function will contine right after the call.
Because of this, we must delay the execution flow in the main thread or
else the program will terminate prematurely. We let it pause in a
processing-time friendly manner by waiting for the enter key to be
pressed. In the end, we stop the daemon so it can do its cleanup tasks.

  getchar (); 

  MHD_stop_daemon (daemon);
  return 0;
}

The first example is now complete.

   Compile it with

cc hellobrowser.c -o hellobrowser -I$PATH_TO_LIBMHD_INCLUDES 
  -L$PATH_TO_LIBMHD_LIBS -lmicrohttpd
 with the two paths set accordingly and run it.

   Now open your favorite Internet browser and go to the address
`http://localhost:8888/', provided that 8888 is the port you chose. If
everything works as expected, the browser will present the message of
the static HTML page it got from our minimal server.

Remarks
=======

   To keep this first example as small as possible, some drastic
shortcuts were taken and are to be discussed now.

   Firstly, there is no distinction made between the kinds of requests
a client could send. We implied that the client sends a GET request,
that means, that he actually asked for some data. Even when it is not
intended to accept POST requests, a good server should at least
recognize that this request does not constitute a legal request and
answer with an error code. This can be easily implemented by checking
if the parameter `method' equals the string "GET" and returning a
`MHD_NO' if not so.

   Secondly, the above practice of queuing a response upon the first
call of the callback function brings with it some limitations.  This is
because the content of the message body will not be received if a
response is queued in the first iteration.  Furthermore, the connection
will be closed right after the response has been transferred then.
This is typically not what you want as it disables HTTP pipelining.
The correct approach is to simply not queue a message on the first
callback unless there is an error.  The `void**' argument to the
callback provides a location for storing information about the history
of the connection; for the first call, the pointer will point to NULL.
A simplistic way to differenciate the first call from others is to check
if the pointer is NULL and set it to a non-NULL value during the first
call.

   Both of these issues you will find addressed in the official
`minimal_example.c' residing in the `src/examples' directory of the
_MHD_ package.  The source code of this program should look very
familiar to you by now and easy to understand.

   For our example, the `must_copy' and `must_free' parameter at the
response construction function could be set to `MHD_NO'. In the usual
case, responses cannot be sent immediately after being queued. For
example, there might be other data on the system that needs to be sent
with a higher priority. Nevertheless, the queue function will return
successfully--raising the problem that the data we have pointed to may
be invalid by the time it is about being sent. This is not an issue
here because we can expect the `page' string, which is a constant
_string literal_ here, to be static. That means it will be present and
unchanged for as long as the program runs.  For dynamic data, one could
choose to either have _MHD_ free the memory `page' points to itself
when it is not longer needed or, alternatively, have the library to
make and manage its own copy of it.

Exercises
=========

   * While the server is running, use a program like `telnet' or
     `netcat' to connect to it. Try to form a valid HTTP 1.1 request
     yourself like

     GET /dontcare HTTP/1.1
     Host: itsme
     <enter>

     and see what the server returns to you.

   * Also, try other requests, like POST, and see how our server does
     not mind and why.  How far in malforming a request can you go
     before the builtin functionality of _MHD_ intervenes and an
     altered response is sent? Make sure you read about the status
     codes in the _RFC_.

   * Add the option `MHD_USE_PEDANTIC_CHECKS' to the start function of
     the daemon in `main'.  Mind the special format of the parameter
     list here which is described in the manual. How indulgent is the
     server now to your input?

   * Let the main function take a string as the first command line
     argument and pass `argv[1]' to the `MHD_start_daemon' function as
     the sixth parameter. The address of this string will be passed to
     the callback function via the `cls' variable. Decorate the text
     given at the command line when the server is started with proper
     HTML tags and send it as the response instead of the former static
     string.

   * _Demanding:_ Write a separate function returning a string
     containing some useful information, for example, the time. Pass
     the function's address as the sixth parameter and evaluate this
     function on every request anew in `answer_to_connection'. Remember
     to free the memory of the string every time after satisfying the
     request.



File: microhttpd-tutorial.info,  Node: Exploring requests,  Next: Response headers,  Prev: Hello browser example,  Up: Top

Exploring requests
******************

   This chapter will deal with the information which the client sends
to the server at every request. We are going to examine the most useful
fields of such an request and print them out in a readable manner. This
could be useful for logging facilities.

   The starting point is the _hellobrowser_ program with the former
response removed.

   This time, we just want to collect information in the callback
function, thus we will just return MHD_NO after we have probed the
request. This way, the connection is closed without much ado by the
server.


static int 
answer_to_connection (void *cls, struct MHD_Connection *connection, 
                      const char *url, 
		      const char *method, const char *version, 
		      const char *upload_data, 
                      size_t *upload_data_size, void **con_cls)
{
  ...  
  return MHD_NO;
}

The ellipsis marks the position where the following instructions shall
be inserted.

   We begin with the most obvious information available to the server,
the request line. You should already have noted that a request consists
of a command (or "HTTP method") and a URI (e.g. a filename).  It also
contains a string for the version of the protocol which can be found in
`version'.  To call it a "new request" is justified because we return
only `MHD_NO', thus ensuring the function will not be called again for
this connection.

printf ("New %s request for %s using version %s\n", method, url, version);

The rest of the information is a bit more hidden. Nevertheless, there
is lot of it sent from common Internet browsers. It is stored in
"key-value" pairs and we want to list what we find in the header.  As
there is no mandatory set of keys a client has to send, each key-value
pair is printed out one by one until there are no more left. We do this
by writing a separate function which will be called for each pair just
like the above function is called for each HTTP request.  It can then
print out the content of this pair.

int print_out_key (void *cls, enum MHD_ValueKind kind, 
                   const char *key, const char *value)
{
  printf ("%s: %s\n", key, value);
  return MHD_YES;
}

To start the iteration process that calls our new function for every
key, the line

MHD_get_connection_values (connection, MHD_HEADER_KIND, &print_out_key, NULL);

needs to be inserted in the connection callback function too. The
second parameter tells the function that we are only interested in keys
from the general HTTP header of the request. Our iterating function
`print_out_key' does not rely on any additional information to fulfill
its duties so the last parameter can be NULL.

   All in all, this constitutes the complete `logging.c' program for
this chapter which can be found in the `examples' section.

   Connecting with any modern Internet browser should yield a handful
of keys. You should try to interpret them with the aid of _RFC 2616_.
Especially worth mentioning is the "Host" key which is often used to
serve several different websites hosted under one single IP address but
reachable by different domain names (this is called virtual hosting).

Conclusion
==========

   The introduced capabilities to itemize the content of a simple GET
request--especially the URI--should already allow the server to satisfy
clients' requests for small specific resources (e.g. files) or even
induce alteration of server state. However, the latter is not
recommended as the GET method (including its header data) is by
convention considered a "safe" operation, which should not change the
server's state in a significant way.  By convention, GET operations can
thus be performed by crawlers and other automatic software.  Naturally
actions like searching for a passed string are fine.

   Of course, no transmission can occur while the return value is still
set to `MHD_NO' in the callback function.

Exercises
=========

   * By parsing the `url' string and delivering responses accordingly,
     implement a small server for "virtual" files. When asked for
     `/index.htm{l}', let the response consist of a HTML page
     containing a link to `/another.html' page which is also to be
     created "on the fly" in case of being requested. If neither of
     these two pages are requested, `MHD_HTTP_NOT_FOUND' shall be
     returned accompanied by an informative message.

   * A very interesting information has still been ignored by our
     logger--the client's IP address.  Implement a callback function

     static int on_client_connect (void *cls,
                                   const struct sockaddr *addr,
     			      socklen_t addrlen)

     that prints out the IP address in an appropriate format. You might
     want to use the POSIX function `inet_ntoa' but bear in mind that
     `addr' is actually just a structure containing other substructures
     and is _not_ the variable this function expects.  Make sure to
     return `MHD_YES' so that the library knows the client is allowed
     to connect (and to then process the request). If one wanted to
     limit access basing on IP addresses, this would be the place to do
     it. The address of your `on_client_connect' function must be
     passed as the third parameter to the `MHD_start_daemon' call.



File: microhttpd-tutorial.info,  Node: Response headers,  Next: Supporting basic authentication,  Prev: Exploring requests,  Up: Top

Response headers
****************

   Now that we are able to inspect the incoming request in great detail,
this chapter discusses the means to enrich the outgoing responses
likewise.

   As you have learned in the _Hello, Browser_ chapter, some obligatory
header fields are added and set automatically for simple responses by
the library itself but if more advanced features are desired,
additional fields have to be created.  One of the possible fields is
the content type field and an example will be developed around it.
This will lead to an application capable of correctly serving different
types of files.

   When we responded with HTML page packed in the static string
previously, the client had no choice but guessing about how to handle
the response, because the server had not told him.  What if we had sent
a picture or a sound file?  Would the message have been understood or
merely been displayed as an endless stream of random characters in the
browser?  This is what the mime content types are for. The header of
the response is extended by certain information about how the data is
to be interpreted.

   To introduce the concept, a picture of the format _PNG_ will be sent
to the client and labeled accordingly with `image/png'.  Once again, we
can base the new example on the `hellobrowser' program.


#define FILENAME "picture.png"
#define MIMETYPE "image/png"

static int 
answer_to_connection (void *cls, struct MHD_Connection *connection, 
		      const char *url, 
                      const char *method, const char *version, 
		      const char *upload_data, 
              	      size_t *upload_data_size, void **con_cls)
{
  unsigned char *buffer = NULL;
  struct MHD_Response *response;

We want the program to open the file for reading and determine its size:

  int fd;
  int ret;
  struct stat sbuf;

  if (0 != strcmp (method, "GET"))
    return MHD_NO;
  if ( (-1 == (fd = open (FILENAME, O_RDONLY))) ||
       (0 != fstat (fd, &sbuf)) )
    {
     /* error accessing file */
      /* ... (see below) */
    }
 /* ... (see below) */

When dealing with files, there is a lot that could go wrong on the
server side and if so, the client should be informed with
`MHD_HTTP_INTERNAL_SERVER_ERROR'.

 
      /* error accessing file */
     if (fd != -1) close (fd);
      const char *errorstr =
        "<html><body>An internal server error has occured!\
                              </body></html>";
      response =
	MHD_create_response_from_buffer (strlen (errorstr), 
				         (void *) errorstr, 
				         MHD_RESPMEM_PERSISTENT);
      if (response)
        {
          ret =
            MHD_queue_response (connection, MHD_HTTP_INTERNAL_SERVER_ERROR,
                                response);
          MHD_destroy_response (response);

          return MHD_YES;
        }
      else
        return MHD_NO;
  if (!ret) 
    {
      const char *errorstr = "<html><body>An internal server error has occured!\
                              </body></html>";

      if (buffer) free(buffer);
    
      response = MHD_create_response_from_buffer (strlen(errorstr), (void*) errorstr,
                                                  MHD_RESPMEM_PERSISTENT);

      if (response)
        {     
          ret = MHD_queue_response (connection, 
	      			    MHD_HTTP_INTERNAL_SERVER_ERROR, 
				    response);
          MHD_destroy_response (response);

          return MHD_YES;    
        } 
      else return MHD_NO;
    }

Note that we nevertheless have to create a response object even for
sending a simple error code.  Otherwise, the connection would just be
closed without comment, leaving the client curious about what has
happened.

   But in the case of success a response will be constructed directly
from the file descriptor:


     /* error accessing file */
     /* ... (see above) */
    }

  response =
    MHD_create_response_from_fd_at_offset (sbuf.st_size, fd, 0);
  MHD_add_response_header (response, "Content-Type", MIMETYPE);
  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);
  MHD_destroy_response (response);

Note that the response object will take care of closing the file
desciptor for us.

   Up to this point, there was little new. The actual novelty is that
we enhance the header with the meta data about the content. Aware of
the field's name we want to add, it is as easy as that:

MHD_add_response_header(response, "Content-Type", MIMETYPE);

We do not have to append a colon expected by the protocol behind the
first field--_GNU libhttpdmicro_ will take care of this.

   The function finishes with the well-known lines

  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);
  MHD_destroy_response (response);
  return ret;
}

The complete program `responseheaders.c' is in the `examples' section
as usual.  Find a _PNG_ file you like and save it to the directory the
example is run from under the name `picture.png'. You should find the
image displayed on your browser if everything worked well.

Remarks
=======

   The include file of the _MHD_ library comes with the header types
mentioned in _RFC 2616_ already defined as macros. Thus, we could have
written `MHD_HTTP_HEADER_CONTENT_TYPE' instead of `"Content-Type"' as
well. However, one is not limited to these standard headers and could
add custom response headers without violating the protocol. Whether,
and how, the client would react to these custom header is up to the
receiver. Likewise, the client is allowed to send custom request
headers to the server as well, opening up yet more possibilities how
client and server could communicate with each other.

   The method of creating the response from a file on disk only works
for static content.  Serving dynamically created responses will be a
topic of a future chapter.

Exercises
=========

   * Remember that the original program was written under a few
     assumptions--a static response using a local file being one of
     them. In order to simulate a very large or hard to reach file that
     cannot be provided instantly, postpone the queuing in the callback
     with the `sleep' function for 30 seconds _if_ the file `/big.png'
     is requested (but deliver the same as above). A request for
     `/picture.png' should provide just the same but without any
     artificial delays.

     Now start two instances of your browser (or even use two machines)
     and see how the second client is put on hold while the first waits
     for his request on the slow file to be fulfilled.

     Finally, change the sourcecode to use
     `MHD_USE_THREAD_PER_CONNECTION' when the daemon is started and try
     again.

   * Did you succeed in implementing the clock exercise yet? This time,
     let the server save the program's start time `t' and implement a
     response simulating a countdown that reaches 0 at `t+60'.
     Returning a message saying on which point the countdown is, the
     response should ultimately be to reply "Done" if the program has
     been running long enough,

     An unofficial, but widely understood, response header line is
     `Refresh: DELAY; url=URL' with the uppercase words substituted to
     tell the client it should request the given resource after the
     given delay again. Improve your program in that the browser (any
     modern browser should work) automatically reconnects and asks for
     the status again every 5 seconds or so. The URL would have to be
     composed so that it begins with "http://", followed by the _URI_
     the server is reachable from the client's point of view.

     Maybe you want also to visualize the countdown as a status bar by
     creating a `<table>' consisting of one row and `n' columns whose
     fields contain small images of either a red or a green light.



File: microhttpd-tutorial.info,  Node: Supporting basic authentication,  Next: Processing POST data,  Prev: Response headers,  Up: Top

Supporting basic authentication
*******************************

   With the small exception of IP address based access control,
requests from all connecting clients where served equally until now.
This chapter discusses a first method of client's authentication and
its limits.

   A very simple approach feasible with the means already discussed
would be to expect the password in the _URI_ string before granting
access to the secured areas. The password could be separated from the
actual resource identifier by a certain character, thus the request
line might look like

GET /picture.png?mypassword

In the rare situation where the client is customized enough and the
connection occurs through secured lines (e.g., a embedded device
directly attached to another via wire) and where the ability to embedd
a password in the URI or to pass on a URI with a password are desired,
this can be a reasonable choice.

   But when it is assumed that the user connecting does so with an
ordinary Internet browser, this implementation brings some problems
about. For example, the URI including the password stays in the address
field or at least in the history of the browser for anybody near enough
to see.  It will also be inconvenient to add the password manually to
any new URI when the browser does not know how to compose this
automatically.

   At least the convenience issue can be addressed by employing the
simplest built-in password facilities of HTTP compliant browsers, hence
we want to start there. It will however turn out to have still severe
weaknesses in terms of security which need consideration.

   Before we will start implementing _Basic Authentication_ as
described in _RFC 2617_, we should finally abandon the bad practice of
responding every request the first time our callback is called for a
given connection. This is becoming more important now because the
client and the server will have to talk in a more bi-directional way
than before to

   But how can we tell whether the callback has been called before for
the particular connection?  Initially, the pointer this parameter
references is set by _MHD_ in the callback. But it will also be
"remembered" on the next call (for the same connection).  Thus, we will
generate no response until the parameter is non-null--implying the
callback was called before at least once. We do not need to share
information between different calls of the callback, so we can set the
parameter to any adress that is assured to be not null. The pointer to
the `connection' structure will be pointing to a legal address, so we
take this.

   The first time `answer_to_connection' is called, we will not even
look at the headers.


static int 
answer_to_connection (void *cls, struct MHD_Connection *connection,
                      const char *url, const char *method, const char *version, 
                      const char *upload_data, size_t *upload_data_size,
                      void **con_cls)
{
  if (0 != strcmp(method, "GET")) return MHD_NO;
  if (NULL == *con_cls) {*con_cls = connection; return MHD_YES;}

  ... 
  /* else respond accordingly */
  ...
}

Note how we lop off the connection on the first condition (no "GET"
request), but return asking for more on the other one with `MHD_YES'.
With this minor change, we can proceed to implement the actual
authentication process.

Request for authentication
==========================

   Let us assume we had only files not intended to be handed out
without the correct username/password, so every "GET" request will be
challenged.  _RFC 2617_ describes how the server shall ask for
authentication by adding a _WWW-Authenticate_ response header with the
name of the _realm_ protected.  MHD can generate and queue such a
failure response for you using the `MHD_queue_basic_auth_fail_response'
API.  The only thing you need to do is construct a response with the
error page to be shown to the user if he aborts basic authentication.
But first, you should check if the proper credentials were already
supplied using the `MHD_basic_auth_get_username_password' call.

   Your code would then look like this:

static int
answer_to_connection (void *cls, struct MHD_Connection *connection,
                      const char *url, const char *method,
                      const char *version, const char *upload_data,
                      size_t *upload_data_size, void **con_cls)
{
  char *user;
  char *pass;
  int fail;
  struct MHD_Response *response;

  if (0 != strcmp (method, MHD_HTTP_METHOD_GET))
    return MHD_NO;
  if (NULL == *con_cls)
    {
      *con_cls = connection;
      return MHD_YES;
    }
  pass = NULL;
  user = MHD_basic_auth_get_username_password (connection, &pass);
  fail = ( (user == NULL) ||
	   (0 != strcmp (user, "root")) ||
	   (0 != strcmp (pass, "pa$$w0rd") ) );  
  if (user != NULL) free (user);
  if (pass != NULL) free (pass);
  if (fail)
    {
      const char *page = "<html><body>Go away.</body></html>";
      response =
	MHD_create_response_from_buffer (strlen (page), (void *) page, 
				       MHD_RESPMEM_PERSISTENT);
      ret = MHD_queue_basic_auth_fail_response (connection,
						"my realm",
						response);
    }
  else
    {
      const char *page = "<html><body>A secret.</body></html>";
      response =
	MHD_create_response_from_buffer (strlen (page), (void *) page, 
				       MHD_RESPMEM_PERSISTENT);
      ret = MHD_queue_response (connection, MHD_HTTP_OK, response);
    }
  MHD_destroy_response (response);
  return ret;
}

   See the `examples' directory for the complete example file.

Remarks
=======

   For a proper server, the conditional statements leading to a return
of `MHD_NO' should yield a response with a more precise status code
instead of silently closing the connection. For example, failures of
memory allocation are best reported as _internal server error_ and
unexpected authentication methods as _400 bad request_.

Exercises
=========

   * Make the server respond to wrong credentials (but otherwise
     well-formed requests) with the recommended _401 unauthorized_
     status code. If the client still does not authenticate correctly
     within the same connection, close it and store the client's IP
     address for a certain time. (It is OK to check for expiration not
     until the main thread wakes up again on the next connection.) If
     the client fails authenticating three times during this period,
     add it to another list for which the `AcceptPolicyCallback'
     function denies connection (temporally).

   * With the network utility `netcat' connect and log the response of
     a "GET" request as you did in the exercise of the first example,
     this time to a file. Now stop the server and let _netcat_ listen
     on the same port the server used to listen on and have it fake
     being the proper server by giving the file's content as the
     response (e.g. `cat log | nc -l -p 8888'). Pretending to think
     your were connecting to the actual server, browse to the
     eavesdropper and give the correct credentials.

     Copy and paste the encoded string you see in `netcat''s output to
     some of the Base64 decode tools available online and see how both
     the user's name and password could be completely restored.



File: microhttpd-tutorial.info,  Node: Processing POST data,  Next: Improved processing of POST data,  Prev: Supporting basic authentication,  Up: Top

Processing POST data
********************

   The previous chapters already have demonstrated a variety of
possibilities to send information to the HTTP server, but it is not
recommended that the _GET_ method is used to alter the way the server
operates. To induce changes on the server, the _POST_ method is
preferred over and is much more powerful than _GET_ and will be
introduced in this chapter.

   We are going to write an application that asks for the visitor's
name and, after the user has posted it, composes an individual response
text. Even though it was not mandatory to use the _POST_ method here,
as there is no permanent change caused by the POST, it is an
illustrative example on how to share data between different functions
for the same connection. Furthermore, the reader should be able to
extend it easily.

GET request
===========

   When the first _GET_ request arrives, the server shall respond with
a HTML page containing an edit field for the name.


const char* askpage = "<html><body>\
                       What's your name, Sir?<br>\
                       <form action=\"/namepost\" method=\"post\">\
                       <input name=\"name\" type=\"text\"\
                       <input type=\"submit\" value=\" Send \"></form>\
                       </body></html>";

The `action' entry is the _URI_ to be called by the browser when
posting, and the `name' will be used later to be sure it is the
editbox's content that has been posted.

   We also prepare the answer page, where the name is to be filled in
later, and an error page as the response for anything but proper _GET_
and _POST_ requests:


const char* greatingpage="<html><body><h1>Welcome, %s!</center></h1></body></html>";

const char* errorpage="<html><body>This doesn't seem to be right.</body></html>";

Whenever we need to send a page, we use an extra function `int
send_page(struct MHD_Connection *connection, const char* page)' for
this, which does not contain anything new and whose implementation is
therefore not discussed further in the tutorial.

POST request
============

   Posted data can be of arbitrary and considerable size; for example,
if a user uploads a big image to the server. Similar to the case of the
header fields, there may also be different streams of posted data, such
as one containing the text of an editbox and another the state of a
button.  Likewise, we will have to register an iterator function that
is going to be called maybe several times not only if there are
different POSTs but also if one POST has only been received partly yet
and needs processing before another chunk can be received.

   Such an iterator function is called by a _postprocessor_, which must
be created upon arriving of the post request.  We want the iterator
function to read the first post data which is tagged `name' and to
create an individual greeting string based on the template and the name.
But in order to pass this string to other functions and still be able
to differentiate different connections, we must first define a
structure to share the information, holding the most import entries.


struct connection_info_struct
{
  int connectiontype;
  char *answerstring;
  struct MHD_PostProcessor *postprocessor; 
};

With these information available to the iterator function, it is able
to fulfill its task.  Once it has composed the greeting string, it
returns `MHD_NO' to inform the post processor that it does not need to
be called again. Note that this function does not handle processing of
data for the same `key'. If we were to expect that the name will be
posted in several chunks, we had to expand the namestring dynamically
as additional parts of it with the same `key' came in. But in this
example, the name is assumed to fit entirely inside one single packet.


static int 
iterate_post (void *coninfo_cls, enum MHD_ValueKind kind, const char *key,
              const char *filename, const char *content_type,
              const char *transfer_encoding, const char *data, 
	      uint64_t off, size_t size)
{
  struct connection_info_struct *con_info = coninfo_cls;

  if (0 == strcmp (key, "name"))
    {
      if ((size > 0) && (size <= MAXNAMESIZE))
        {
          char *answerstring;
          answerstring = malloc (MAXANSWERSIZE);
          if (!answerstring) return MHD_NO;
      
          snprintf (answerstring, MAXANSWERSIZE, greatingpage, data);
          con_info->answerstring = answerstring;      
        } 
      else con_info->answerstring = NULL;

      return MHD_NO;
    }

  return MHD_YES;
}

Once a connection has been established, it can be terminated for many
reasons. As these reasons include unexpected events, we have to
register another function that cleans up any resources that might have
been allocated for that connection by us, namely the post processor and
the greetings string. This cleanup function must take into account that
it will also be called for finished requests other than _POST_ requests.


void request_completed (void *cls, struct MHD_Connection *connection, 
     		        void **con_cls,
                        enum MHD_RequestTerminationCode toe)
{
  struct connection_info_struct *con_info = *con_cls;

  if (NULL == con_info) return;
  if (con_info->connectiontype == POST)
    {
      MHD_destroy_post_processor (con_info->postprocessor);        
      if (con_info->answerstring) free (con_info->answerstring);
    }
  
  free (con_info);
  *con_cls = NULL;   
}

_GNU libmicrohttpd_ is informed that it shall call the above function
when the daemon is started in the main function.


...
daemon = MHD_start_daemon (MHD_USE_SELECT_INTERNALLY, PORT, NULL, NULL,
                           &answer_to_connection, NULL, 
			   MHD_OPTION_NOTIFY_COMPLETED, &request_completed, NULL,
			   MHD_OPTION_END);
...

Request handling
================

With all other functions prepared, we can now discuss the actual
request handling.

   On the first iteration for a new request, we start by allocating a
new instance of a `struct connection_info_struct' structure, which will
store all necessary information for later iterations and other
functions.


static int 
answer_to_connection (void *cls, struct MHD_Connection *connection, 
		      const char *url, 
                      const char *method, const char *version, 
		      const char *upload_data, 
                      size_t *upload_data_size, void **con_cls)
{
  if(NULL == *con_cls) 
    {
      struct connection_info_struct *con_info;

      con_info = malloc (sizeof (struct connection_info_struct));
      if (NULL == con_info) return MHD_NO;
      con_info->answerstring = NULL;

If the new request is a _POST_, the postprocessor must be created now.
In addition, the type of the request is stored for convenience.

      if (0 == strcmp (method, "POST")) 
        {      
          con_info->postprocessor 
	    = MHD_create_post_processor (connection, POSTBUFFERSIZE, 
                                         iterate_post, (void*) con_info);   

          if (NULL == con_info->postprocessor) 
            {
              free (con_info); 
              return MHD_NO;
            }
          con_info->connectiontype = POST;
        } 
      else con_info->connectiontype = GET;

The address of our structure will both serve as the indicator for
successive iterations and to remember the particular details about the
connection.

      *con_cls = (void*) con_info; 
      return MHD_YES;
    }

The rest of the function will not be executed on the first iteration. A
_GET_ request is easily satisfied by sending the question form.

  if (0 == strcmp (method, "GET")) 
    {
      return send_page (connection, askpage);     
    }

In case of _POST_, we invoke the post processor for as long as data
keeps incoming, setting `*upload_data_size' to zero in order to
indicate that we have processed--or at least have considered--all of it.

  if (0 == strcmp (method, "POST")) 
    {
      struct connection_info_struct *con_info = *con_cls;

      if (*upload_data_size != 0) 
        {
          MHD_post_process (con_info->postprocessor, upload_data,	
	                    *upload_data_size);
          *upload_data_size = 0;
          
          return MHD_YES;
        } 
      else if (NULL != con_info->answerstring) 
        return send_page (connection, con_info->answerstring);
    }

Finally, if they are neither _GET_ nor _POST_ requests, the error page
is returned.

  return send_page(connection, errorpage); 
}

These were the important parts of the program `simplepost.c'.

